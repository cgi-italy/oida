import { autorun, computed, makeObservable, observable, action, observe } from 'mobx';
import moment from 'moment';

import { SubscriptionTracker, AoiValue, DateRangeValue, QueryFilter, DATE_FIELD_ID, DATE_RANGE_FIELD_ID, randomColorFactory } from '@oida/core';
import { GroupLayer, MapLayer, DataFilters } from '@oida/state-mobx';

import { Dataset, DATASET_AOI_FILTER_KEY, DATASET_TIME_RANGE_FILTER_KEY, DATASET_SELECTED_TIME_FILTER_KEY } from './dataset';
import { DatasetConfig } from '../types/dataset-config';
import { DatasetViz, DatasetVizConfig } from './dataset-viz';
import { DatasetTimeDistributionViz } from './dataset-time-distribution-viz';
import { TimeRange } from './time-range';
import { TimeSearchDirection } from '../types/dataset-time-distribution-provider';
import { DatasetAnalyses } from './dataset-analyses';


export type DatasetExplorerItemProps = {
    datasetConfig: DatasetConfig;
    explorer: DatasetExplorer;
};

/**
 * Automatically generated by the {@link DatasetExplorer.addDataset} method. It manages the creation of the {@link Dataset} instance,
 * its main map visualization (when the {@link DatasetConfig} mapView is specified) and
 * {@link DatasetTimeDistributionViz | time distribution} state (when {@link DatasetConfig} timeDistribution is specified).
 * It is automatically binded to the {@link DatasetExplorer} state. All {@link DatasetExplorer.commonFilters} are automatically
 * propagated to the {@link DatasetExplorerItem.dataset}, in order to be available to all the associated
 * {@link DatasetViz | dataset visualizations}. When a time filter is set on the DatasetExplorer, the corresponding dataset
 * time filter is set to the nearest dataset product time, based on the {@link DatasetExplorerItem.timeDistributionViz} configuration.
 * The {@link DatasetExplorerItem.timeDistributionViz} search params are automatically updated based on the state of
 * {@link DatasetExplorer.timeExplorer}
 *
 */
export class DatasetExplorerItem {
    readonly dataset: Dataset;
    readonly mapViz: DatasetViz<MapLayer | undefined> | undefined;
    readonly timeDistributionViz: DatasetTimeDistributionViz | undefined;
    readonly explorer: DatasetExplorer;

    protected pendingNearestTimeRequests_: Promise<any> | undefined;
    protected subscriptionTracker_: SubscriptionTracker;

    constructor(props: DatasetExplorerItemProps) {
        this.dataset = new Dataset({
            config: props.datasetConfig,
            onSelectedDateUpdate: ((dt: Date) => {
                // sync the dataset selected date with the global explorer selected date
                props.explorer.setSelectedDate(dt);
            })
        });
        this.explorer = props.explorer;

        if (this.explorer.vizExplorer && props.datasetConfig.mapView) {

            this.mapViz = DatasetViz.create<any>({
                dataset: this.dataset,
                vizType: props.datasetConfig.mapView.type,
                config: props.datasetConfig.mapView.config
            });
        }

        if (this.explorer.timeExplorer && props.datasetConfig.timeDistribution) {
            this.timeDistributionViz = new DatasetTimeDistributionViz({
                dataset: this.dataset,
                config: {
                    provider: props.datasetConfig.timeDistribution.provider
                }
            });
        }

        this.subscriptionTracker_ = new SubscriptionTracker();

        this.afterInit_();
    }

    dispose() {
        if (this.pendingNearestTimeRequests_ && this.pendingNearestTimeRequests_.cancel) {
            this.pendingNearestTimeRequests_.cancel();
            this.pendingNearestTimeRequests_ = undefined;
        }
        if (this.mapViz) {
            this.mapViz.dispose();
        }

        this.subscriptionTracker_.unsubscribe();
    }

    protected afterInit_() {

        //propagate the dataset explorer common filters to the dataset filters
        const filterTrackerDisposer = observe(this.explorer.commonFilters.items, (change) => {
            if (change.type === 'add' || change.type === 'update') {
                this.applyFilter_(change.newValue);
            } else if (change.type === 'delete') {
                this.dataset.filters.unset(change.oldValue.key);
            }
        });

        this.explorer.commonFilters.items.forEach((filter) => {
            this.applyFilter_(filter);
        });

        this.subscriptionTracker_.addSubscription(filterTrackerDisposer);

        const timeExplorer = this.explorer.timeExplorer;
        const timeDistributionViz = this.timeDistributionViz;
        if (timeExplorer && timeDistributionViz) {
            //automatically update the time distribution search params according to the
            //time explorer visible range
            const timeDistributionSearchParamsDisposer = autorun(() => {
                const active = timeExplorer.active;
                let timeRange = timeExplorer.visibleRange.range;
                if (active) {
                    timeDistributionViz.setSearchParams({
                        ...timeRange,
                        resolution: timeExplorer.visibleRange.resolution
                    });
                }
            });

            this.subscriptionTracker_.addSubscription(timeDistributionSearchParamsDisposer);
        }
    }

    protected applyFilter_(filter: QueryFilter) {
        const timeDistributionProvider = this.dataset.config.timeDistribution?.provider;
        if (
            filter.key === DATASET_SELECTED_TIME_FILTER_KEY
            && filter.value !== undefined
            && this.explorer.vizExplorer?.nearestMatch
            && timeDistributionProvider
        ) {
            // find the dataset product nearest to the selected time
            if (this.pendingNearestTimeRequests_ && this.pendingNearestTimeRequests_.cancel) {
                this.pendingNearestTimeRequests_.cancel();
                this.pendingNearestTimeRequests_ = undefined;
            }
            this.pendingNearestTimeRequests_ = timeDistributionProvider.getNearestItem(
                filter.value
            ).then((item) => {
                if (!item || !item.start) {
                    this.dataset.filters.unset(
                        DATASET_SELECTED_TIME_FILTER_KEY
                    );
                } else {
                    let currentDatasetTime = this.dataset.filters.get(DATASET_SELECTED_TIME_FILTER_KEY)?.value;
                    let nearestMatch = item.start;
                    if (!currentDatasetTime || currentDatasetTime.getTime() !== nearestMatch.getTime()) {
                        this.dataset.filters.set(
                            DATASET_SELECTED_TIME_FILTER_KEY,
                            nearestMatch,
                            filter.type
                        );
                    }
                }
            }).catch((error) => {
                this.dataset.filters.unset(
                    DATASET_SELECTED_TIME_FILTER_KEY
                );
            });
        } else {
            this.dataset.filters.set(filter.key, filter.value, filter.type);
        }
    }
}

/**
 * A class to manage the datasets time exploration state. It is part of the {@link DatasetExplorer} state
 * and all datasets added to the explorer will provide their products {@link DatasetTimeDistributionViz | time distribution}
 * in the time range set here.
 */
export class DatasetTimeExplorer {
    @observable.ref active: boolean;
    /** The explorer visible time range */
    readonly visibleRange: TimeRange;

    constructor() {
        this.active = false;
        this.visibleRange = new TimeRange({
            start: moment().subtract(1, 'month').toDate(),
            end: moment().toDate(),
        });

        makeObservable(this);
    }

    @action
    setActive(active: boolean) {
        this.active = active;
    }
}

/**
 * A class to manage the datasets map visualizations. It is part of the {@link DatasetExplorer} state
 */
export class DatasetVizExplorer {
    readonly mapLayer: GroupLayer;
    @observable.ref nearestMatch: boolean;

    constructor() {
        this.mapLayer = new GroupLayer({
            id: 'explorerDatasetViews'
        });
        this.nearestMatch = true;
    }

    get active() {
        return this.mapLayer.visible;
    }

    @action
    setActive(active: boolean) {
        this.mapLayer.visible.setValue(active);
    }

    @action
    setNearestMatch(enabled: boolean) {
        this.nearestMatch = enabled;
    }
}

export type DatasetsExplorerConfig = {
    disableTimeExplorer?: boolean;
    disableProductSearch?: boolean;
    disableMapView?: boolean;
};

export type DatasetsExplorerProps = {
    /** A layer that will contain all datasets map visualizations */
    mapLayer: GroupLayer;
    config?: DatasetsExplorerConfig;
};

const randomColor = randomColorFactory();

/**
 * Main class to manage a combined exploration of a set of EO Datasets.
 */
export class DatasetExplorer {
    readonly config: DatasetsExplorerConfig;
    /**
     * The layer group containing all datasets map visualizations (i.e. layers and analyses).
     */
    readonly mapLayer: GroupLayer;
    /**
     * A set of filters common to all EO datasets. They usually include an Area of interest and a time filter
     */
    readonly commonFilters: DataFilters;
    /** The dataset time explorer state  */
    readonly timeExplorer: DatasetTimeExplorer | undefined;
    /** The map explorer. It contains all dataset map visualizations */
    readonly vizExplorer: DatasetVizExplorer | undefined;
    /** The dataset analyses */
    readonly analyses: DatasetAnalyses;
    /** The datasets array */
    readonly items = observable.array<DatasetExplorerItem>([], {deep: false});

    protected subscriptionTracker_: SubscriptionTracker;

    constructor(props: DatasetsExplorerProps) {
        this.config = props.config || {};
        this.mapLayer = props.mapLayer;
        this.commonFilters = new DataFilters();
        if (!props.config?.disableTimeExplorer) {
            this.timeExplorer = new DatasetTimeExplorer();
        }
        if (!props.config?.disableMapView) {
            this.vizExplorer = new DatasetVizExplorer();
            this.mapLayer.children.add(this.vizExplorer.mapLayer);
        }

        this.analyses = new DatasetAnalyses({
            active: true
        });
        this.mapLayer.children.add(this.analyses.geometryLayer);

        this.subscriptionTracker_ = new SubscriptionTracker();

        this.afterInit_();

        makeObservable(this);
    }

    @computed
    get aoi(): AoiValue | undefined {
        return this.commonFilters.get(DATASET_AOI_FILTER_KEY)?.value;
    }

    @computed
    get toi(): DateRangeValue | undefined {
        return this.commonFilters.get(DATASET_TIME_RANGE_FILTER_KEY)?.value;
    }

    @computed
    get selectedDate(): Date | undefined {
        return this.commonFilters.get(DATASET_SELECTED_TIME_FILTER_KEY)?.value;
    }

    @computed
    get shouldEnableTimeExplorer(): boolean {
        return this.timeExplorer !== undefined && this.items.some(dataset => !!dataset.timeDistributionViz);
    }

    @action
    setSelectedDate(date: Date | undefined) {
        this.commonFilters.set(DATASET_SELECTED_TIME_FILTER_KEY, date, DATE_FIELD_ID);
    }

    @action
    setToi(dateRange: DateRangeValue | undefined) {
        this.commonFilters.set(DATASET_TIME_RANGE_FILTER_KEY, dateRange, DATE_RANGE_FIELD_ID);
    }

    @action
    addDataset(datasetConfig: DatasetConfig) {

        if (!datasetConfig.color) {
            datasetConfig.color = randomColor();
        }
        const item = new DatasetExplorerItem({
            datasetConfig: datasetConfig,
            explorer: this
        });

        this.items.push(item);
        if (this.vizExplorer && item.mapViz?.mapLayer) {
            this.vizExplorer.mapLayer.children.add(item.mapViz.mapLayer, 0);
        }
    }

    @action
    removeDataset(datasetId: string) {
        let item = this.items.find(item => item.dataset.id === datasetId);
        if (item) {
            item.dispose();
            this.items.remove(item);

            if (this.vizExplorer && item.mapViz?.mapLayer) {
                this.vizExplorer.mapLayer.children.remove(item.mapViz.mapLayer);
            }
        }
    }

    @action
    moveDataset(idx, newIdx) {
        let item = this.items[idx];
        if (item) {
            this.items.splice(idx, 1);
            this.items.splice(newIdx, 0, item);

            if (this.vizExplorer && item.mapViz?.mapLayer) {
                this.vizExplorer.mapLayer.children.move(item.mapViz.mapLayer, this.items.length - newIdx - 1);
            }
        }
    }

    getDataset(datasetId: string) {
        return this.items.find(item => item.dataset.id === datasetId);
    }

    dispose() {
        this.subscriptionTracker_.unsubscribe();
        this.items.forEach(item => item.dispose());
        this.items.clear();

        if (this.vizExplorer) {
            this.mapLayer.children.remove(this.vizExplorer.mapLayer);
        }
    }

    protected afterInit_() {
        const timeExplorer = this.timeExplorer;

        if (timeExplorer) {
            const autoTimeZoomDisposer = autorun(() => {
                let selectedDate = this.selectedDate;
                let toi = this.toi;
                if (selectedDate) {
                    timeExplorer.visibleRange.centerDate(selectedDate, {
                        notIfVisible: true,
                        animate: true
                    });
                } else if (toi) {
                    timeExplorer.visibleRange.centerRange(toi.start, toi.end, {
                        notIfVisible: true,
                        animate: true,
                        margin: 0.2
                    });
                }
            });

            this.subscriptionTracker_.addSubscription(autoTimeZoomDisposer);
        }
    }

}
