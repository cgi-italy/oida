/**
 * A factory that can generates object of type T given a string identifier and a configuration object.
 * New types can be dynamically registered by calling the {@link IDynamicFactory.register} method
 * @template T The output type generated by the factory create
 * @template CONFIG The type specific configuration input of the create method.
 * @template COMMON_CONFIG The configuration part common to all types
 */
export interface IDynamicFactory<
    T,
    CONFIG extends Record<string, any> = Record<string, any>,
    COMMON_CONFIG extends Record<string, any> = Record<string, any>
> {
    /**
     * Register a new object type
     * @param id The type identifier
     * @param objectCreator The factory creation function. It receives a configuration object and returns an
     * object of type T
     */
    register<R extends string>(id: R, objectCreator: (config: COMMON_CONFIG & CONFIG[R]) => T): void;
    /**
     * Create an object given its type idenitifier (it shall be previously registered with {@Link IDynamicFactory.create}) and
     * a configuration object
     * @param id The type identifier
     * @param config The configuration object
     */
    create<R extends string>(id: R, config: COMMON_CONFIG & CONFIG[R]): T | undefined;
    /**
     * Check if a type identifier was registered in the factory
     */
    isRegistered(id: string): boolean;
}

/**
 * Create a {@link IDynamicFactory | Dynamic Factory} instance
 * @template T see {@link IDynamicFactory.T}
 * @template CONFIG see {@link IDynamicFactory}
 * @template COMMON_CONFIG see {@link IDynamicFactory}
 */
export const createDynamicFactory = <
    T = any,
    CONFIG extends Record<string, any> = Record<string, any>,
    COMMON_CONFIG extends Record<string, any> = Record<string, any>
>(
    factoryId: string
): IDynamicFactory<T, CONFIG, COMMON_CONFIG> => {
    const REGISTERED_TYPES: { [s: string]: (config: any) => T } = {};

    const getRegisteredType = (id: string) => {
        return REGISTERED_TYPES[id];
    };

    return {
        register: <R extends string>(id: R, objectCreator: (config: COMMON_CONFIG & CONFIG[R]) => T) => {
            if (getRegisteredType(id)) {
                throw new Error(`Dynamic factory ${factoryId}: factory already registered for type ${id}`);
            }
            REGISTERED_TYPES[id] = objectCreator;
        },
        create: <R extends string>(id: R, config: COMMON_CONFIG & CONFIG[R]): T | undefined => {
            const objectCreator = getRegisteredType(id);
            if (objectCreator) {
                return objectCreator(config);
            }
        },
        isRegistered: (id: string): boolean => {
            return getRegisteredType(id) !== undefined;
        }
    };
};
